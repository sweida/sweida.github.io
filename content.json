{"meta":{"title":"Start Here","subtitle":null,"description":"个人技术学习分享博客，前端技术分享","author":"施伟达","url":"https://sweida.github.io"},"pages":[],"posts":[{"title":"云服务器创建及php环境搭建","slug":"云服务器创建及php环境搭建","date":"2018-09-26T08:31:08.000Z","updated":"2018-09-28T08:44:49.564Z","comments":true,"path":"archives/51805.html","link":"","permalink":"https://sweida.github.io/archives/51805.html","excerpt":"","text":"云服务最好选择linux Centos 6.x系统，创建后，默认用户 root，设置默认密码推荐使用 MobaXterm (类似工具xshell, putty) 工具连接云服务器。输入服务器公网IP，默认端口22，输入刚刚设置的用户名 root 和密码，显示界面如下(MobaXterm可以保存用户密码，下次登陆输入 root 即可自动登陆用户 root) 添加端口号默认是没有开启端口号的，需要去 安全组 里吧几个常用的端口号添加上(8080, 80, 有多个站点也需要设置多个端口号)添加后 安装linux面板，选择宝塔官网：https://www.bt.cn/download/linux.html Centos 系统安装命令：12345yum install -y wgetwget -O install.sh http://download.bt.cn/install/install.shsh install.sh 默认端口是8888，114.116.72.19:8888 打开操作界面， 在软件管理里安装 Nignx、web环境、php、mysql，选择对应的版本安装 安装解压rar文件12345678910111213141516171819# 下载wget http://www.rarlab.com/rar/rarlinux-x64-5.3.0.tar.gz# 解压tar -zxvf rarlinux-x64-5.3.0.tar.gz# 进入rar文件夹cd rar# 进行配置 make# 输出&gt;&gt;&gt; mkdir -p /usr/local/bin&gt;&gt;&gt; mkdir -p /usr/local/lib&gt;&gt;&gt; cp rar unrar /usr/local/bin&gt;&gt;&gt; cp rarfiles.lst /etc&gt;&gt;&gt; cp default.sfx /usr/local/lib# 可以用rar命令开始解压 解压和压缩rar文件12345# 解压 dist.rar 到当前目录rar x dist.rar# 压缩文件，将 dist目录打包为 dist.rarrar dist.rar ./dist/ 解压zip文件1unzip dist.zip","categories":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}],"tags":[{"name":"服务器搭建","slug":"服务器搭建","permalink":"https://sweida.github.io/tags/服务器搭建/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}]},{"title":"laravel创建api","slug":"laravel创建api","date":"2018-09-18T08:58:58.000Z","updated":"2018-09-19T06:25:38.377Z","comments":true,"path":"archives/61614.html","link":"","permalink":"https://sweida.github.io/archives/61614.html","excerpt":"","text":"修改laravel默认时区laravel 和 php 一样 默认的是英国的格林尼治时间 和我们相差大概8小时laravel 框架其实 内置了设置时区的方式打开 config 下的 app.php 找到 timezone 123'timezone' =&gt; 'UTC',# 修改成'timezone' =&gt; 'PRC', 数据库操作之 - Eloquent ORM模型的建立及查询数据 简介：laravel所自带的Eloquent ORM 是一个ActiveRecord实现，用于数据库操作。每个数据表都有一个与之对应的模型，用于数据表交互。 创建模块model1php artisan make:model User mysql添加数据库1insert into users (username, `password`) value('佟丽娅', '123456')","categories":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://sweida.github.io/tags/PHP/"},{"name":"laravel","slug":"laravel","permalink":"https://sweida.github.io/tags/laravel/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}]},{"title":"laravel连接数据库mysql与创建数据库表","slug":"laravel连接数据库mysql与创建数据库表","date":"2018-09-18T07:50:34.000Z","updated":"2018-10-09T10:30:43.479Z","comments":true,"path":"archives/42085.html","link":"","permalink":"https://sweida.github.io/archives/42085.html","excerpt":"","text":"连接数据库Laravel中数据库配置文件为config/database.php，打开该文件，默认内容如下,不需要修改这里的: 1234567891011121314151617181920212223242526272829303132&lt;?phpreturn [ //默认返回结果集为PHP对象实例 'fetch' =&gt; PDO::FETCH_CLASS, //默认数据库连接为mysql，可以在.env文件中修改DB_CONNECTION的值 'default' =&gt; env('DB_CONNECTION', 'mysql'), 'connections' =&gt; [ //sqlite数据库相关配置 'sqlite' =&gt; [ 'driver' =&gt; 'sqlite', 'database' =&gt; storage_path('database.sqlite'), 'prefix' =&gt; '', ], //mysql数据库相关配置 'mysql' =&gt; [ 'driver' =&gt; 'mysql', 'host' =&gt; env('DB_HOST', '127.0.0.1'), 'port' =&gt; env('DB_PORT', '3306'), 'database' =&gt; env('DB_DATABASE', 'forge'), 'username' =&gt; env('DB_USERNAME', 'forge'), 'password' =&gt; env('DB_PASSWORD', ''), 'unix_socket' =&gt; env('DB_SOCKET', ''), 'charset' =&gt; 'utf8mb4', 'collation' =&gt; 'utf8mb4_unicode_ci', 'prefix' =&gt; '', 'strict' =&gt; true, 'engine' =&gt; null, ], ]; ]; 修改.env对应值1234567891011121314APP_NAME=LaravelAPP_ENV=localAPP_KEY=base64:x2NKVZImZBLgeCYg+1uTcw64hxi5SeNbnI2oqww7TRw=APP_DEBUG=trueAPP_URL=http://localhostLOG_CHANNEL=stackDB_CONNECTION=mysqlDB_HOST=127.0.0.1DB_PORT=3306 // 端口号DB_DATABASE=laraveldb // 数据库名DB_USERNAME=root // 用户名DB_PASSWORD=root // 数据库密码 注：执行migration时, 如果报了这个错误 could not find driver需要允许pdo扩展，需要将php安装文件php.ini文件中将pdo_mysql这一行前的分号删除。 创建数据库表设计数据库 使用migration1php artisan make:migration create_table_users --create=users migration users文件up方法12345678910111213// create_table_users.phppublic function up()&#123; Schema::create('users', function (Blueprint $table) &#123; $table-&gt;increments('id'); $table-&gt;string('username')-&gt;unique(); $table-&gt;string('email')-&gt;unique()-&gt;nullable(); $table-&gt;string('phone')-&gt;unique()-&gt;nullable(); $table-&gt;string('password'); $table-&gt;text('intro')-&gt;nullable(); $table-&gt;timestamps(); &#125;);&#125; 可用的列类型模式构建器包含您在构建表时可能指定的各种列类型： 命令 描述 $table-&gt;boolean(&#39;confirmed&#39;); BOOLEAN等效列。 $table-&gt;char(&#39;name&#39;, 100); CHAR等效列，可选长度。 $table-&gt;date(&#39;created_at&#39;); DATE等效列。 $table-&gt;float(&#39;amount&#39;, 8, 2); FLOAT等效列，具有精度（总位数）和刻度（十进制数字）。 $table-&gt;increments(&#39;id&#39;); 自动递增UNSIGNED INTEGER（主键）等效列。 $table-&gt;ipAddress(&#39;visitor&#39;); IP地址等效列。 $table-&gt;json(&#39;options&#39;); JSON等效列。 $table-&gt;longText(&#39;description&#39;); LONGTEXT等效列。 $table-&gt;string(&#39;name&#39;, 100); VARCHAR等效列，可选长度。 $table-&gt;text(&#39;description&#39;); TEXT等效列。 $table-&gt;time(&#39;sunrise&#39;); TIME等效列。 $table-&gt;timestamps(); 添加created_at和updated_at等效列。 $table-&gt;year(&#39;birth_year&#39;); YEAR等效列。 列修饰符在向数据库表添加列时可以使用多个列“修饰符”。例如，要使列“可为空”，您可以使用以下nullable方法：下面是所有可用列修饰符的列表。此列表不包括索引修饰符： 修改 描述 -&gt;unique() 唯一值 -&gt;nullable() 可以为空 -&gt;nullable($value = true) 允许（默认情况下）将null值插入列中 -&gt;default($value) 为列指定“默认”值 -&gt;after(&#39;column&#39;) 将列放在“另一列”之后（MySQL） -&gt;autoIncrement() 将INTEGER列设置为自动增量（主键） -&gt;charset(&#39;utf8&#39;) 为列指定字符集（MySQL） -&gt;collation(&#39;utf8_unicode_ci&#39;) 为列指定排序规则（MySQL / SQL Server） -&gt;comment(&#39;my comment&#39;) 在列中添加注释（MySQL） -&gt;first() 将列“first”放在表中（MySQL） -&gt;storedAs($expression) 创建存储生成的列（MySQL） -&gt;unsigned() 将INTEGER列设置为UNSIGNED（MySQL） -&gt;useCurrent() 设置TIMESTAMP列以使用CURRENT_TIMESTAMP作为默认值 -&gt;virtualAs($expression) 创建虚拟生成列（MySQL） 查看数据库执行运行结果，如果没报错再执行添加表1php artisan migrate --pretend 12# 往表格添加字段php artisan make:migration add_votes_to_users_table --table=users 如果表存在，删除数据库表12&lt;!-- mysql --&gt;drop table users; 添加数据库表1234php artisan migrate# Migrating: 2018_09_18_024606_create_table_users# Migrated: 2018_09_18_024606_create_table_users 添加表成功 回滚迁移1234php artisan migrate:rollback# 回滚最后五次迁移php artisan migrate:rollback --step=5 重新创建整个数据1234php artisan migrate:refresh# 重新创建整个数据并添加模型工厂的数据php artisan migrate:refresh --seed","categories":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://sweida.github.io/tags/PHP/"},{"name":"laravel","slug":"laravel","permalink":"https://sweida.github.io/tags/laravel/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}]},{"title":"python保存json文件并输出中文","slug":"python文件保存中文文字","date":"2018-09-07T09:46:27.000Z","updated":"2018-09-07T10:53:04.161Z","comments":true,"path":"archives/55006.html","link":"","permalink":"https://sweida.github.io/archives/55006.html","excerpt":"","text":"python保存json文件并输出中文123456789101112131415import iosendData = [ &#123; id: 1, name: '奥特曼' &#125;,&#123; id: 2, name: '小怪兽' &#125;]with io.open('data.json', 'w', encoding=\"utf-8\") as file: json.dump(sendData, file, ensure_ascii=False, sort_keys=True, indent=2)print('保存成功') 工作原理 我们使用 io.open 然后在第一个 open 语句中使用 encoding 参数对信息进行编码，然后在解码信息时再在第二个 open 语句中使用该参数。 请注意，我们应该只在文本模式下使用 open 语句时的使用编码。 每当我们编写一个使用Unicode文字的程序（通过在字符串之前放置一个 u ）就像我们上面使用的那样，我们必须确保 Python 本身被告知我们的程序使用UTF-8，我们必须把 # encoding=utf-8 注释在我们程序的顶部。 json.dump()将其保存为json格式，ensure_ascii=False禁止使用ascii编码保存，indent=2 Tab为2个空格大小 json.loads()读取json文件 创建文件夹1234import osif not os.path.exists('data'): os.mkdir('data') 输出今天日期12345678import time# 获取今天年月日nowdate = time.localtime(time.time()) # 获得当前时间戳today = time.strftime('%Y-%m-%d %H:%M:%S', nowdate) # 转换成指定格式print(today)&gt;&gt;&gt; 2018-09-07 18:08:12","categories":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sweida.github.io/tags/python/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}]},{"title":"python简单例子","slug":"python简单例子","date":"2018-09-07T06:37:20.000Z","updated":"2018-09-07T10:53:27.485Z","comments":true,"path":"archives/56097.html","link":"","permalink":"https://sweida.github.io/archives/56097.html","excerpt":"","text":"python 简易猜数字游戏用户可以一直猜，每猜一次都要重复运行一次程序，直到猜对为止。 这巧妙地阐述了 while 语句的用法。12345678910111213141516171819number = 23running = Truewhile running: guess = int(input('Enter an integer : ')) if guess == number: print('Congratulations, you guessed it.') # 这会导致 while 循环停止 running = False elif guess &lt; number: print('No, it is a little higher than that.') else: print('No, it is a little lower than that.')else: print('The while loop is over.') # 你可以在此处继续进行其它你想做的操作print('Done') 输出123456789$ python while.pyEnter an integer : 50No, it is a little lower than that.Enter an integer : 22No, it is a little higher than that.Enter an integer : 23Congratulations, you guessed it.The while loop is over.Done else语句块会在 while 循环的条件变为 False 时执行——甚至有可能在第一次检查条件时，条件就是 False 。如果 while 循环中有一个 else 从句，它总是会执行到，除非用 break 语句跳出循环。 我们将True 和 False 称为布尔类型，而且你可以认为它们分别等于数值 1 和 0 。 for 循环for..in 语句是另一种循环语句，它会 迭代 对象序列，即会遍历序列中的的每个项。在后面的章节中，我们将详细了解 序列 。目前你只需要知道的是，序列只是一个有序的项的集合。示例（保存为 for.py）：1234for i in range(1, 5): print(i)else: print('The for loop is over') 输出：123456$ python for.py1234The for loop is over 查找字符串123456789101112131415# 这是一个字符串对象name = 'Swaroop'if name.startswith('Swa'): print('Yes, the string starts with \"Swa\"')if 'a' in name: print('Yes, it contains the string \"a\"')if name.find('war') != -1: print('Yes, it contains the string \"war\"')delimiter = '_*_'mylist = ['Brazil', 'Russia', 'India', 'China']print(delimiter.join(mylist)) 输出：12345$ python ds_str_methods.pyYes, the string starts with \"Swa\"Yes, it contains the string \"a\"Yes, it contains the string \"war\"Brazil_*_Russia_*_India_*_China 模块的 __name__每一个模块都有一个名称，在模块中我们可以通过判断语句来确定模块的名称。这在一种情形下特别有用：确定模块被导入了？还是在独立的运行。如之前提到过的，当模块第一次被导入的时候，模块的代码将被执行。我们可以通过这一点，让模块在被导入和独立运行时执行不同的操作。通过模块的 __name__ 属性可以实现这个功能。 示例（另存为 module_using_name.py）：1234if __name__ == &apos;__main__&apos;: print(&apos;我是自己运行时显示&apos;)else: print(&apos;我是在被import时显示的&apos;) 输出：1234567$ python module_using_name.py我是自己运行时显示$ python&gt;&gt;&gt; import module_using_name我是在被import时显示的&gt;&gt;&gt; 代码是如何工作的？ 每一个 Python 模块都定义了各自的 __name__。如果其值为 __main__，这说明用户正在单独运行这个模块，这时我们可以进行合适的操作 __init__ 方法对 Python 类来说，许多方法名有特别的重要性。现在，我们来考察一个重要的 __init__ 方法。 __init__ 方法将在类的对象被初始化（也就是创建）的时候自动的调用。这个方法将按照你的想法 初始化 对象（通过给对象传递初始值）。请注意这个名字的开头和结束都是双下划线。 例子（保存为文件 oop_init.py ）：1234567891011class Person: def __init__(self, name): self.name = name def say_hi(self): print('Hello, my name is', self.name)p = Person('Swaroop')p.say_hi()# 上面两行也可以写成下面这种形式# Person('Swaroop').say_hi() 输出12$ python oop_init.pyHello, my name is Swaroop 这是如何工作的 这里，我们定义了 __init__ 方法。这个方法除了通常的 self 变量之外，还有一个参数 name 。 这里我们创建了一个新的也叫做 name 的域。注意这里有两个不同的变量却都被叫做 name 。这是没有问题的，因为带点的标记 self.name 表示有一个叫做 name 的域是这个类的一部分，而另外一个 name 是一个局部变量。这里我们显式地指出使用哪个变量，因此没有任何冲突。 当新建一个新的 Person 类的实例 p 的时候，我们通过调用类名的方式来创建这个新的实例，在紧跟着的括号中填入初始化参数： p = Person(&#39;Swaroop&#39;) 。 我们没有显式的调用 __init__ 这个方法，这是这个方法特殊之处。 正如 say_hi 方法所示的，现在我们在我们的方法之中可以使用 self.name 这个域了。","categories":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sweida.github.io/tags/python/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}]},{"title":"win7彻底隐藏文件夹","slug":"win7彻底隐藏文件夹","date":"2018-08-23T06:21:32.000Z","updated":"2018-09-19T07:12:02.996Z","comments":true,"path":"archives/30997.html","link":"","permalink":"https://sweida.github.io/archives/30997.html","excerpt":"","text":"有时候我们存储为隐藏的一些私人或者重要的文件却无意中显示出来了，让这些私人或者重要的文件被人窥见；虽然这些文件是隐藏的，但还是没彻底隐藏起来，那下面就介绍我一直使用的隐藏文件夹的方法，让文件夹里的文件成为你的专属。 隐藏文件夹在命令提示符下输入：attrib +s +a +h +r d:不告诉你，回车，就彻底隐藏了D:\\不告诉你文件夹了，即使在显示隐藏的文件、文件夹和驱动器下也可以将其隐藏起来。 隐藏后如何查看文件夹东西直接在地址栏输文件夹名不告诉你即可打开文件夹，神不知鬼不觉 取消隐藏需要在命令提示符下输入：attrib -s -a -h -r d:不告诉你，回车，此时不告诉你文件夹就显示出来了。 命令解析attrib 显示、设置或删除指派给文件或目录的只读、存档、系统以及隐藏属性。如果在不含参数的情况下使用，则 attrib 会显示当前目录中所有文件的属性。123456789101112131415+s 设置系统属性。+a 设置存档文件属性。+r 设置只读属性。+h 设置隐藏属性。-s 清除系统属性。-a 清除存档文件属性。-r 清除只读属性。-h 清除隐藏属性。 利用浏览器自带截取整张网页 按F12打开调试框 按ctrl+shift+p调出命令输入框 输入cap，选择capture full size screenshot即可全屏截取网页","categories":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}],"tags":[{"name":"干货","slug":"干货","permalink":"https://sweida.github.io/tags/干货/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}]},{"title":"视频或者文件批量合并","slug":"视频或者文件批量合并","date":"2018-08-23T02:01:41.000Z","updated":"2018-08-23T06:39:03.423Z","comments":true,"path":"archives/53638.html","link":"","permalink":"https://sweida.github.io/archives/53638.html","excerpt":"","text":"多个视频文件或文本文档合并成一个文件在当前目录下建立一个文本文挡，内容copy /b 1.ts + 2.ts + 3.ts new.ts，然后保存，将文本文档后缀改成bat格式。打开即可将目录下的ts文件以二进制顺序合并为new.ts文件。 txt文本同样也可以用这种方法合并","categories":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}],"tags":[{"name":"干货","slug":"干货","permalink":"https://sweida.github.io/tags/干货/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}]},{"title":"Ruby on Rails简介","slug":"Ruby on Rails简介","date":"2018-08-12T17:18:10.000Z","updated":"2018-08-13T06:14:30.501Z","comments":true,"path":"archives/27628.html","link":"","permalink":"https://sweida.github.io/archives/27628.html","excerpt":"","text":"什么是Rails Rails是Ruby on Rails的官方简称，非官方简称为RoR。在RubyOnRails的官网对Rails的定义是：Rails is a web application development framework written in the Ruby language. 翻译过来就是，Rails 是一个用Ruby语言写的，web应用开发的框架。 所谓web应用框架，是一种开发框架，用来支持动态网站、网络应用程序及网络服务的开发。这种框架有助于减轻网页开发时共同性活动的工作负荷，例如许多框架提供数据库访问接口、标准样板及会话管理等，课提升代码的可再用性。 而Rails的存在，是为了相比于其他的语言或框架，你可以用更少的代码去完成相同的事情。而很多资深的Rails框架使用者也表示，使用这种框架开发更有乐趣。 Rails哲学的两种主要指导原则 DRY:Don’t Repeat Yourself (不要重复自己): DRY是软件开发的一个原则，它表示“系统的每一部分，必须有一个单一的，明确的，权威的表示，必须能够表达所应表达的内容，而不含重复的代码。这样使我们的代码由更好的可维护性、扩展性，且有更少的错误。 Convention Over Configuration (约定优于配置): Rails认为web应用程序中的很多操作都有最好的方式去完成，并将其设定为默认值，这使得程序员无需在配置文件中设置很多细节。如果你依照Rails的惯例，将会有令人惊艳的成果，但是对初学者可能会有点困难，例如，当你从一个已经存在的应用程序开始写，将会有很多隐藏的设定在应用程序的代码里。这些设定会让程序更加简洁，但是也会让初学者非常困惑。但是当你熟悉了这个惯例之后，将会有如虎添翼的效果。 什么是RubyRails是一套使用Ruby开发的网站框架，因此要认识Rails，对Ruby有一定的了解也是必须的。 Ruby是个一种面向对象、命令式、函数式、动态的编程语言，在20世纪90年代中期由日本人松本行弘(Matz)设计并开发。Ruby有着简单哲学、高生产力、精巧、自然的语法，它的设计目的是要让程式设计师能够快乐的写程式。 静态语言和动态语言的差别在于，前者的变数型别需要事前宣告，后者则是执行器才动态决定。实务上的表现就是，Ruby可以被动态直译(就像PHP)，所以没有编译(如C、Java)，这加速了迭代式开发。一个Ruby程序可以动态产生程序，即使正在执行也可以修改。Rails内部就使用这个能力，来让你可以简单享受所谓的“Magic”。 为何选择RubyRuby是一套非常重视使用性(Usability)的编程语言，非常看重代码的可读性及维护性。Matz在设计Ruby的时候，就特别考量一般人容不容易了解，这也是为什么我们常常会听到Ruby的代码自然简洁又漂亮。 Ruby也是目前做Domain-specific language(DSL)，特别是Internal DSL最为成功的语言。透过DSL，代码不但可以拥有非常好的可读性，也可以大幅增加生产力。 Rails 优势:Rails是包装功能，更有效率，许多基础上另一个具有以下特点。 元编程 : 其他框架使用大量的代码生成从零开始。使用元编程技术方案编写程序。 Ruby是的元编程最好的语言之一，Rails使用此功能。Rails的也采用代码生成，元编程繁重，但更依赖。 活动记录 : Rails 介绍活动记录的框架，这将对象保存到数据库。活动记录发现 Rails版本的数据库架构中的列，并自动附加到对象域使用元编程。 约定优于配置: 大多数Web开发框架.NET或Java，迫使写配置代码的页面。如果遵循建议的命名约定时，Rails不需要太多的配置。 脚手架: 经常在发展的早期阶段，以帮助应用程序快速创建临时代码，主要组成部分是如何一起工作。 Rails自动创建很多需要的脚手架。 内置测试: Rails创建简单的自动化测试，也可以扩展。Rails也提供支持所谓的安全带及装置，使更容易编写和运行测试用例的代码。 Ruby可以执行所有耙子实用程序的自动化测试。 三种环境: Rails 提供了三种默认的环境：开发，测试和生产。每个人的行为方式略有不同，更容易使整个软件开发周期。例如，Rails的测试数据库中创建一个新的副本，每个测试运行。 MVC框架简介 MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写。是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 Model（模型）：处理数据及业务逻辑，通常负责对数据库进行存取操作。 View（视图）：显示用户界面，处理数据显示，通常依据模型数据来创建。 Controller（控制器）：处理用户请求及应用逻辑，通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 MVC 分层有助于管理复杂的应用程序，同时也简化了分组开发。不同的开发人员可同时开发视图、控制器逻辑和业务逻辑。","categories":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}],"tags":[{"name":"Rails","slug":"Rails","permalink":"https://sweida.github.io/tags/Rails/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}]},{"title":"laravel学习笔记","slug":"laravel学习笔记","date":"2018-08-03T16:43:57.000Z","updated":"2018-09-18T08:50:36.238Z","comments":true,"path":"archives/22843.html","link":"","permalink":"https://sweida.github.io/archives/22843.html","excerpt":"","text":"Laravel 5.6学习笔记要求:PHP &gt;= 7.1.3 通过 Laravel 安装器通过 Composer 安装 Laravel 安装器 (Composer安装看上一篇文章)1composer global require \"laravel/installer\" 安装完成后，通过简单的 laravel new 命令即可在当前目录下创建一个新的 Laravel 应用，例如，laravel new blog 将会创建一个名为 blog 的新应用，且包含所有 Laravel 依赖。该安装方法比通过 Composer 安装要快很多：1234laravel new blog// 或者composer create-project --prefer-dist laravel/laravel blog 本地开发服务器如果你在本地安装了 PHP，并且想要使用 PHP 内置的开发环境服务器为应用提供服务，可以使用 Artisan 命令1php artisan serve 该命令将会在本地启动开发环境服务器，这样在浏览器中通过 http://localhost:8000 即可访问应用：","categories":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://sweida.github.io/tags/PHP/"},{"name":"laravel","slug":"laravel","permalink":"https://sweida.github.io/tags/laravel/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}]},{"title":"PHP安装和PHP包管理器composer安装","slug":"PHP安装和PHP包管理器composer安装","date":"2018-08-03T16:11:01.000Z","updated":"2018-08-08T03:08:28.517Z","comments":true,"path":"archives/47504.html","link":"","permalink":"https://sweida.github.io/archives/47504.html","excerpt":"","text":"下载PHP你可以从 windows.php.net/download 下载二进制安装包。 解压后, 最好将你的 PHP 所在的根目录（php.exe 所在的文件夹）添加到 PATH 环境变量中，这样就可以从命令行中直接执行 PHP。 添加到 PATH 环境变量步骤 进入控制面板并打开“系统”图标（我的电脑 -&gt; 系统属性 -&gt; 高级系统属性） 点击“环境变量”按钮 在“系统变量”栏中 找到 Path 这一项 鼠标双击 Path 这一项 在最后加入你的 PHP 目录，包括前面的“;” 例如（;D:\\php-7.2.8） 保存后重新打开命令行输入php -v, 输出版本号即成功 Windows环境下安装composer对于Windows 的用户而言最简单的获取及执行方法就是使用 ComposerSetup 安装程序，它会执行一个全局安装并设置你的 $PATH，所以你在任意目录下在命令行中使用 composer。 下载完成后自动选取php.exe所在目录，然后一直点下一步直到完成完成后打开命令行输入 composer，输出下面即成功 composer更新1composer global update 使用Composer镜像用法修改 composer 的全局配置文件，打开命令行窗口输入命令1composer config -g repo.packagist composer https://packagist.phpcomposer.com","categories":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://sweida.github.io/tags/PHP/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}]},{"title":"ES6使你的代码更简洁","slug":"ES6使你的代码更简洁","date":"2018-07-28T18:05:28.000Z","updated":"2018-08-08T03:08:28.505Z","comments":true,"path":"archives/57328.html","link":"","permalink":"https://sweida.github.io/archives/57328.html","excerpt":"","text":"展开操作符ES6引入了 ... 操作符，它被称为 “展开操作符”。 它有两个主要用途：将数组或对象传播到新的数组或对象中，并将多个参数合并到一个数组中。 第一个用例是你可能遇到的最多的用例，所以我们先看看。1234let a = [3, 4, 5]let b = [1, 2, ...a, 6]console.log(b)// [1, 2, 3, 4, 5, 6] 这对于将数组中的元素作为一组变量传递给函数时非常有用。123456function foo(a, b, c) &#123; console.log(`a=$&#123;a&#125;, b=$&#123;b&#125;, c=$&#123;c&#125;`)&#125; let data = [5, 15, 2]foo( ...data) // a=5, b=15, c=2 它也可以展开对象，将每个键值对输入到新对象中。（对象展开实际上是在提案的第4阶段，并将在 ES2018 中正式推出，目前仅支持 Chrome 60 或更高版本，Firefox 55 或更高版本 ，以及 node 6.4.0 或更高版本）1234let car = &#123; type: 'vehicle ', wheels: 4&#125;let fordGt = &#123; make: 'Ford', ...car, model: 'GT'&#125;console.log(fordGt) // &#123;make: 'Ford', model: 'GT', type: 'vehicle', wheels: 4&#125; 函数可以使用 rest（剩余）参数语法接受任意数量的参数作为数组。123456function ArgumentsArray(...theArguments) &#123; console.log(theArguments)&#125; ArgumentsArray('hi', 'there', 'bud')// 将打印 ['hi', 'there', 'bud'] Object.values()返回一个对象属性值的数组。12345678const icecreamColors = &#123; chocolate: 'brown', vanilla: 'white', strawberry: 'red',&#125; const colors = Object.values(icecreamColors)// colors = [\"brown\", \"white\", \"red\"] Object.keys()返回一个对象属性名的数组。12345678const icecreamColors = &#123; chocolate: 'brown', vanilla: 'white', strawberry: 'red',&#125; const types = Object.keys(icecreamColors)// types = [\"chocolate\", \"vanilla\", \"strawberry\"] Object.entries()创建一个数组，其中包含一个对象的键/值对数组。12345678const weather = &#123; rain: 0, temperature: 24, humidity: 33,&#125; const entries = Object.entries(weather)// entries = [['rain', 0], ['temperature', 24], ['humidity', 33]] Object.assign()允许对象组合在一起。不再需要这个方法，因为您可以使用上面说的对象展开语法。与对象展开操作符一样，Object.assign() 也不会执行深层克隆。当谈到深度克隆对象时，Lodash 是你最好的朋友。12345678910const firstObject = &#123; firstName: 'Robert'&#125; const secondObject = &#123; lastName: 'Cooper'&#125; const combinedObject = Object.assign(firstObject, secondObject)// combinedObject = &#123; firstName: 'Robert', lastName: 'Cooper' &#125; 随机排列数组使用 Array.sort() 来重新排序元素，比较器中使用 Math.random() 。1234const shuffle = arr =&gt; arr.sort( () =&gt; Math.random() - 0.5)// shuffle([1,2,3]) -&gt; [2,3,1] 数字数组求和使用 Array.reduce() 将每个值添加到累加器，并使用0值初始化。1234const sum = arr =&gt; arr.reduce( (acc, val) =&gt; acc + val, 0)// sum([1,2,3,4]) -&gt; 10 数组取样随，机获取数组中的1个元素使用 Math.random() 生成一个随机数，乘以 length，并使用 Math.floor() 舍去小数获得到最接近的整数。这个方法也适用于字符串。12const sample = arr =&gt; arr[Math.floor(Math.random() * arr.length)]// sample([3, 7, 9, 11]) -&gt; 9 反转一个字符串用数组解构和 Array.reverse() 来反转字符串中字符的顺序。使用 join(‘’)合并字符串。12const reverseString = str =&gt; [...str].reverse().join('')// reverseString('foobar') -&gt; 'raboof' 在指定的范围内生成一个随机整数使用 Math.random() 生成一个随机数并将其映射到所需的范围，使用 Math.floor() 使其成为一个整数。12const num = (min, max) =&gt; Math.floor(Math.random() * (max - min + 1)) + minnum(0, 5) -&gt; 2","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sweida.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"JavaScript 编码简写技巧","slug":"JavaScript 编码简写技巧","date":"2018-07-28T17:07:34.000Z","updated":"2018-08-08T03:08:28.511Z","comments":true,"path":"archives/56432.html","link":"","permalink":"https://sweida.github.io/archives/56432.html","excerpt":"","text":"for 循环简写普通写法：123for (let i = 0; i &lt; allImgs.length; i++)&#123;&#125; 简写：123for (let index of allImgs)&#123;&#125; 对象属性简写在 JavaScript 中定义对象字面量非常容易。ES6 提供了一种更简单的方法来将属性分配给对象。如果 name 和 key 名字相同，则可以利用简写符号。 普通写法：1const obj = &#123; x:x, y:y &#125; 简写：1const obj = &#123; x, y &#125; 隐式返回简写我们经常使用 return 关键字来返回一个函数的最终结果。使用单条语句的箭头函数将隐式返回求值结果（该函数必须省略大括号（{}）才能省略 return 关键字）。 要返回多行表达式（如对象字面量），那么需要用 () 而不是 {} 来包裹你的函数体。这样可以确保代码作为一个单独的表达式被求值返回。 普通写法：123function calcCircumference(diameter) &#123; return Math.PI * diameter&#125; 简写：123calcCircumference = diameter =&gt; ( Math.PI * diameter;) 解构赋值简写如果你正在使用任何流行的 web 框架，那么你很有可能会使用数组或者对象字面量形式的数据在组件和 API 之间传递信息。一旦组件接收到数据对象，你就需要将其展开。 普通写法：123456789const observable = require('mobx/observable')const action = require('mobx/action')const runInAction = require('mobx/runInAction') const store = this.props.storeconst table = this.props.tableconst loading = this.props.loadingconst errors = this.props.errorsconst entity = this.props.entity 简写：123import &#123; observable, action, runInAction &#125; from 'mobx'const &#123; store, table, loading, errors, entity &#125; = this.props 你甚至可以给变量重新分配变量名：12// const contact = this.props.entityconst &#123; store, table, loading, errors, entity:contact &#125; = this.props 双位非运算符简写位操作符是你在刚学习 JavaScript 时会学到的一个特性，但是如果你不处理二进制的话，基本上是从来都不会用上的。 但是，双位运算符有一个非常实用的使用场景：可以用来代替 Math.floor。双位非运算符的优势在于它执行相同操作的速度更快。 普通写法：1Math.floor(4.9) === 4 //true 简写：1~~4.9 === 4 //true Array.find 简写如果你曾经使用原生 JavaScript 写一个查找函数，你可能会使用 for 循环。在 ES6 中，你可以使用名为find()的新数组函数。 普通写法：12345678910111213const pets = [ &#123; type: 'Dog', name: 'Max'&#125;, &#123; type: 'Cat', name: 'Karl'&#125;, &#123; type: 'Dog', name: 'Tommy'&#125;,] function findDog(name) &#123; for(let i = 0; i&lt;pets .length; ++i) &#123; if(pets[i].type === 'Dog' &amp;&amp; pets[i].name === 'Tommy') &#123; return pets[i]; &#125; &#125;&#125; 简写：1234pet = pets.find(pet =&gt; pet.type ==='Dog' &amp;&amp; pet.name === 'Tommy')console.log(pet) // &#123; type: 'Dog', name: 'Tommy' &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sweida.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"vscode 前端最佳配置","slug":"vscode 前端最佳配置","date":"2018-07-28T07:17:33.000Z","updated":"2018-08-08T03:08:28.533Z","comments":true,"path":"archives/6132.html","link":"","permalink":"https://sweida.github.io/archives/6132.html","excerpt":"","text":"vscode前端开发的利器，安装上一些好用的插件和修改个人配置文件，更是所向披靡，开发起来快别人几条街。下面详细解释vscode的个人配置点击左下角的设置按钮 &gt; 设置 &gt; 右边栏的用户设置，修改user setting文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&#123; // VScode主题配置 \"search.followSymlinks\": false, // 解决cpu飙到100%问题 \"git.autofetch\": true, \"editor.tabSize\": 2, \"workbench.colorTheme\": \"TwoStones\", // 忽略工程打开的文件夹 \"files.exclude\": &#123; \"**/.git\": false, \"**/.svn\": true, \"**/.DS_Store\": true, \"**/node_modules\": true &#125;, // 搜索忽略的文件夹 \"search.exclude\": &#123; \"**/node_modules\": true, \"**/bower_components\": true &#125;, // 代码补全和高亮 \"emmet.triggerExpansionOnTab\": true, // 启用tab展开缩写 \"emmet.includeLanguages\": &#123; \"vue-html\": \"html\", \"vue\": \"html\", \"javascript\": \"javascriptreact\", \"jsx-sublime-babel-tags\": \"javascriptreact\" // 在react的jsx中添加对emmet的支持 &#125;, \"emmet.syntaxProfiles\": &#123; \"vue-html\": \"html\", \"vue\": \"html\" &#125;, // eslint支持vue文件 \"eslint.autoFixOnSave\": true, \"eslint.validate\": [ \"javascript\", \"javascriptreact\", \"html\", \"vue\", &#123; \"language\": \"html\", \"autoFix\": true &#125;, &#123; \"language\": \"vue\", \"autoFix\": true &#125; ], \"eslint.options\": &#123; \"plugins\": [\"html\"] &#125;, // stylus格式化样式 \"stylusSupremacy.insertColons\": false, // 是否插入冒号 \"stylusSupremacy.insertSemicolons\": false, // 是否插入分好 \"stylusSupremacy.insertBraces\": false, // 是否插入大括号 \"stylusSupremacy.insertNewLineAroundImports\": false, // import之后是否换行 \"stylusSupremacy.insertNewLineAroundBlocks\": false, // 两个选择器中是否换行 // prettier结合vetur代码格式化 \"prettier.semi\": false, // 格式化去掉行尾分号 \"prettier.singleQuote\": true, // 格式化为单引号 \"prettier.trailingComma\": \"all\", // 尽可能控制尾随逗号的打印 \"prettier.eslintIntegration\": true, // 开启 eslint 支持 \"vetur.validation.template\": false, // v-for key报错 \"vetur.format.defaultFormatter.html\": \"js-beautify-html\", // html格式化依赖 \"javascript.format.insertSpaceBeforeFunctionParenthesis\": true, //函数前加空格 \"vetur.format.defaultFormatter.js\": \"vscode-typescript\", //没有下边这个 上边不生效 \"vetur.format.defaultFormatterOptions\": &#123; \"js-beautify-html\": &#123; \"wrap_attributes\": \"force-aligned\", // 属性强制折行对齐 &#125; &#125;, \"editor.quickSuggestions\": &#123; \"strings\": true //自动显示建议 &#125;, // sync配置 \"sync.gist\": \"4096fae8cf25eae5babfa3aa3a71a4e7\", \"sync.lastUpload\": \"2018-07-27T19:25:02.036Z\", \"sync.autoDownload\": false, \"sync.autoUpload\": false, \"sync.lastDownload\": \"\", \"sync.forceDownload\": false, \"sync.host\": \"\", \"sync.pathPrefix\": \"\", \"sync.quietSync\": false, \"sync.askGistName\": false, \"sync.removeExtensions\": true, \"sync.syncExtensions\": true, \"git.enableSmartCommit\": true, \"git.confirmSync\": false, \"explorer.confirmDelete\": false, \"explorer.confirmDragAndDrop\": false, \"[python]\": &#123; \"editor.tabSize\": 4, &#125;, \"atomKeymap.promptV3Features\": true, \"editor.multiCursorModifier\": \"ctrlCmd\", \"editor.formatOnPaste\": true, \"liveServer.settings.donotShowInfoMsg\": true, \"liveServer.settings.donotVerifyTags\": true, // vue代码格式，因为vetur有bug不能代码格式，所有用beautify \"beautify.language\": &#123; \"html\": [ \"vue\" ] &#125;&#125; 另外介绍几款超强大的插件Settings Sync同步vscode的插件和配置，更换电脑时就可以用之前保存好的插件和配置了 live server开启一个服务器，代码更新页面就会自动刷新了 bookmarks代码标签，代码标记后会保存起来，查找代码就很方便了 path Intelliense路径提示，妈妈再也不用担心我路径写错迷路了 Bracket Pair Colorizer括号颜色标记，很好的区分各个代码块","categories":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://sweida.github.io/tags/vscode/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}]},{"title":"ES6模块的import和export用法总结","slug":"ES6模块的import和export用法总结","date":"2018-07-23T15:12:00.000Z","updated":"2018-08-08T03:08:28.505Z","comments":true,"path":"archives/8964.html","link":"","permalink":"https://sweida.github.io/archives/8964.html","excerpt":"","text":"ES6模块主要有两个功能：export和import export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口 import用于在一个模块中加载另一个含有export接口的模块。 例子一123456// foo.jslet sex=\"boy\";let echo=function(value)&#123; console.log(value)&#125;export &#123;sex, echo&#125; 1234567891011121314// boo.js// 通过import获取foo.js文件的内部变量，需要加&#123;&#125;引用// &#123;&#125;括号内的变量来自于foo.js文件export出的变量标识符，可以按需引入import &#123;sex, echo&#125; from \"./foo.js\"console.log(sex) // boyecho(sex) // boy// 写法2 (不推荐) 所有模块全部暴露import * as test from './foo.js'console.log(test.sex) // boytest.echo(test.sex) // boy foo.js文件也可以按如下export语法写，但不如上边直观，不太推荐。123456// foo.jsexport let sex=\"boy\";export function echo(value)&#123; console.log(value)&#125; 例子二1234// foo.jslet a='my name is xiaoming'let b='this is a bird'export default &#123;a, b&#125; 1234import anyoneword from './foo.js'console.log(anyoneword) //一个对象里面包含a,b两个变量。console.log(anyoneword.a) // my name is xiaomingconsole.log(anyoneword.b) // this is a bird export 和 export default两个导出，下面我们讲讲它们的区别 export与export default均可用于导出常量、函数、文件、模块等 在一个文件或模块中，export、import可以有多个，export default仅有一个 通过export方式导出，在导入时要加{ }，export default则不需要 export能直接导出变量表达式，export default不行。 export default输出后，import的模块可以起任何变量名 export defualt12345678// xxx.jsexport defualt function FunName() &#123; return fetch(&#123; url: '/article/list', method: 'get' &#125;);&#125;// 一个文件内最多只能有一个export default 引用123// xxx.js文件的export default输出一个叫做default的变量，然后系统允许你为它取任意名字。// 所以可以为import的模块起任何变量名，且不需要用大括号包含import anyName from '../xxx.js' export1234567// xxx.jsexport function FunName() &#123; return fetch(&#123; url: '/article/list', method: 'get' &#125;);&#125; 1import &#123;xxx&#125; from '../xxx.js'","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sweida.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"vue项目首屏优化之路由懒加载","slug":"vue项目首屏优化之路由懒加载","date":"2018-07-08T15:54:32.000Z","updated":"2018-08-08T03:08:28.535Z","comments":true,"path":"archives/28920.html","link":"","permalink":"https://sweida.github.io/archives/28920.html","excerpt":"","text":"当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。 实现 首先，可以将异步组件定义为返回一个 Promise 的工厂函数 然后使用动态 import语法来定义代码分块点。 结合这两者，定义一个能够被 Webpack 自动代码分割的异步组件。 123456// 原始improt Foo from './Foo'// 第一种方法，需要配合babel的syntax-dynamic-import插件使用const Foo = () =&gt; import('./Foo.vue')// 第二种方法const Foo = resolve =&gt; require(['./Foo.vue'], resolve) 在路由配置中什么都不需要改变，只需要像往常一样使用 Foo：12345const router = new VueRouter(&#123; routes: [ &#123; path: '/Foo', component: Foo &#125; ]&#125;) 结合上面，路由配置如下1234567891011121314151617181920212223242526272829// router 文件夹下的index.js文件import Vue from 'vue'improt Router from 'vue-router'improt Foo from '@/pages/Foo' // 某页面Vue.use(Router)// 非懒加载/* const routes = [ &#123; path: '/', name: 'Foo', component: Foo &#125;] */// 懒加载const routes= [ &#123; path: '/', name: 'Foo', componet: () =&gt; improt('@/pages/Foo') //其实就相当于按需加载 &#125;]const router = new Router(&#123; routes&#125;)export default router 这就是将不同路由对应的组件分割成不同的代码块，然后当路由被访问时才加载对应组件。 main.js入口文件关于路由的配置1234567improt router from './router' //引入路由配置文件new Vue(&#123; el: '#app', router, // 注入到根实例中 render: h =&gt; h(App)&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://sweida.github.io/tags/vue/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"vue使用rem适配移动端","slug":"vue使用rem适配移动端","date":"2018-07-03T01:56:10.000Z","updated":"2018-08-08T03:08:28.535Z","comments":true,"path":"archives/33799.html","link":"","permalink":"https://sweida.github.io/archives/33799.html","excerpt":"","text":"vu移动端使用vant-ui、mint-ui，想做移动端适配，可以借助px2rem 插件方便的将px单位转为了rem。 安装1npm install px2rem-loader lib-flexible --save 在项目入口文件main.js中引入lib-flexible1import 'lib-flexible/flexible.js' 在build下的 utils.js中，找到exports.cssLoaders = function (options) { } ，在里面添加：1234567891011121314151617181920const px2remLoader = &#123; loader: 'px2rem-loader', options: &#123; remUnit: 37.5 &#125;&#125;// 找到generateLoaders 方法，只需添加 postcssLoader，修改成：function generateLoaders (loader, loaderOptions) &#123; const loaders = options.usePostCSS ? [cssLoader, postcssLoader, px2remLoader] : [cssLoader] if (loader) &#123; loaders.push(&#123; loader: loader + '-loader', options: Object.assign(&#123;&#125;, loaderOptions, &#123; sourceMap: options.sourceMap &#125;) &#125;) &#125;&#125; index.html的head里的meta最好修改成下面，禁止手机端放大页面1&lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"&gt; 重启项目，会发现默认的px自动被转为rem 了","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://sweida.github.io/tags/vue/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"python之os模块","slug":"python之os模块","date":"2018-06-30T18:28:30.000Z","updated":"2018-08-08T03:08:28.533Z","comments":true,"path":"archives/26568.html","link":"","permalink":"https://sweida.github.io/archives/26568.html","excerpt":"","text":"Python的标准库中的os模块包含普遍的操作系统功能。os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口 加载1import os os 常用方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 取得当前目录os.getcwd()# 列出指定目录的所有文件os.listdir('dirname')# 删除文件os.remove(‘path/filename’)# 重命名文件os.rename(oldname, newname)# 生成目录树下的所有文件名os.walk()# 改变目录os.chdir('dirname')# 创建目录/多层目录os.mkdir/makedirs('dirname')# 删除目录/多层目录os.rmdir/removedirs('dirname')# 改变目录权限os.chmod()# 去掉目录路径，返回文件名os.path.basename(‘path/filename’)# 去掉文件名，返回目录路径os.path.dirname(‘path/filename’)# 将分离的各部分组合成一个路径名os.path.join(path1[,path2[,...]])# 返回( dirname(), basename())元组os.path.split('path')# 返回 (filename, extension) 元组os.path.splitext()# 分别返回最近访问、创建、修改时间os.path.getatime\\ctime\\mtime# 返回文件大小os.path.getsize()# 是否存在os.path.exists()# 是否为绝对路径os.path.isabs()# 是否为目录os.path.isdir()# 是否为文件os.path.isfile()","categories":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sweida.github.io/tags/python/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}]},{"title":"Python爬虫工具requests-html","slug":"Python爬虫工具requests-html","date":"2018-06-29T06:25:05.000Z","updated":"2018-08-08T03:08:28.521Z","comments":true,"path":"archives/47067.html","link":"","permalink":"https://sweida.github.io/archives/47067.html","excerpt":"","text":"requests 作者 kennethreitz 出了一个新库 requests-html，requests-html 是基于现有的框架 PyQuery、Requests、lxml、beautifulsoup4等库进行了二次封装，作者将Requests设计的简单强大的优点带到了该项目中。 requests官方中文教程requests-html官方教程 安装1pip install requests-html 开始使用12from requests_html import HTMLSessionsession = HTMLSession() GET和POST请求123456789101112131415161718# GET请求url = \"http://kaoshi.edu.sina.com.cn/college/scorelist?tab=batch&amp;wl=1&amp;local=2&amp;batch=&amp;syear=2013\"r = session.get(url)r.encoding='utf-8' # 解决中文乱码问题print(r.text)# 获取的网页的内容存储到本地with open('test.html','wb') as f: f.write(r.content)# POST请求url = 'https://shuju.wdzj.com/plat-info-target.html'params = &#123;'wdzjPlatId': 59,'type': 1, 'target1': 1, 'target2': 0&#125;r = session.post(url, params=params)print(r.text)###定制请求头headers = &#123;'user-agent': 'my-app/0.0.1'&#125;r = session.get(url, headers=headers) 获取页面链接123456789101112131415161718r = session.get('http://www.w3school.com.cn')print(r.html.links)# 输出 (太多，中间省略部分)&#123;'http://www.w3ctech.com/', '/glossary/index.asp', '/html5/html5_quiz.asp', '/php/index.asp', '/asp/index.asp', '/php/php_ref_date.asp', 'http://wetest.qq.com/?from=links_w3school', '/asp/asp_ref.asp', '/tags/index.asp', '/xmldom/index.asp', '/example/csse_examples.asp', '/w.asp', '/index.html', 'http://weibo.com/w3schoolcomcn', '/ws.asp', '/b.asp', '/cssref/index.asp', '/jquerymobile/index.asp',...'/xsl/xsl_languages.asp','/example/html_examples.asp'&#125;# 获取绝对地址t = r.html.absolute_linksprint(t)&#123;'http://www.w3school.com.cn/media/index.asp','http://www.w3school.com.cn/glossary/index.asp','http://www.w3school.com.cn/php/php_ref.asp','http://www.w3school.com.cn/site/index.asp',...'http://www.w3school.com.cn/asp/asp_quiz.asp'&#125; 使用JQuery选择器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# 获取3cschoool首页左侧的菜单列表 first=True表示找到的第一个‘HTML教程’menuList = r.html.find('#navsecond &gt; ul', first=True)print(menuList.text)# 输出HTMLHTML5XHTMLCSSCSS3TCP/IP# 找出所有菜单的标题和链接menuList = r.html.find('#navsecond &gt; ul')for menu in menuList: print(menu.text) # 获得标题 print(menu.absolute_links) # 获得链接# 输出HTMLHTML5XHTMLCSSCSS3TCP/IP&#123;'http://www.w3school.com.cn/html5/index.asp', 'http://www.w3school.com.cn/css/index.asp', 'http://www.w3school.com.cn/html/index.asp', 'http://www.w3school.com.cn/css3/index.asp', 'http://www.w3school.com.cn/xhtml/index.asp', 'http://www.w3school.com.cn/tcpip/index.asp'&#125;JavaScriptHTML DOMjQueryjQuery MobileAJAXJSONDHTMLE4XWMLScript&#123;'http://www.w3school.com.cn/jquerymobile/index.asp', 'http://www.w3school.com.cn/js/index.asp', 'http://www.w3school.com.cn/e4x/index.asp', 'http://www.w3school.com.cn/wmlscript/index.asp', 'http://www.w3school.com.cn/jquery/index.asp', 'http://www.w3school.com.cn/htmldom/index.asp', 'http://www.w3school.com.cn/ajax/index.asp', 'http://www.w3school.com.cn/json/index.asp', 'http://www.w3school.com.cn/dhtml/index.asp'&#125;PHPSQLASPADOVBScript&#123;'http://www.w3school.com.cn/asp/index.asp', 'http://www.w3school.com.cn/php/index.asp', 'http://www.w3school.com.cn/ado/index.asp', 'http://www.w3school.com.cn/vbscript/index.asp', 'http://www.w3school.com.cn/sql/index.asp'&#125;XMLDTDXML DOMXSLXSLTXSL-FOXPathXQueryXLinkXPointerSchemaXFormsWAPSVG&#123;'http://www.w3school.com.cn/schema/index.asp', 'http://www.w3school.com.cn/xquery/index.asp', 'http://www.w3school.com.cn/xml/index.asp', 'http://www.w3school.com.cn/xslfo/index.asp', 'http://www.w3school.com.cn/xlink/index.asp', 'http://www.w3school.com.cn/wap/index.asp', 'http://www.w3school.com.cn/xforms/index.asp', 'http://www.w3school.com.cn/xsl/xsl_languages.asp', 'http://www.w3school.com.cn/dtd/index.asp', 'http://www.w3school.com.cn/xpath/index.asp', 'http://www.w3school.com.cn/svg/index.asp', 'http://www.w3school.com.cn/xmldom/index.asp', 'http://www.w3school.com.cn/xsl/index.asp'&#125;Web ServicesWSDLSOAPRSSRDF&#123;'http://www.w3school.com.cn/rdf/index.asp', 'http://www.w3school.com.cn/soap/index.asp', 'http://www.w3school.com.cn/webservices/index.asp', 'http://www.w3school.com.cn/rss/index.asp', 'http://www.w3school.com.cn/wsdl/index.asp'&#125;ASP.NETWeb PagesRazorMVCWeb Forms&#123;'http://www.w3school.com.cn/aspnet/razor_intro.asp', 'http://www.w3school.com.cn/aspnet/mvc_intro.asp', 'http://www.w3school.com.cn/aspnet/index.asp', 'http://www.w3school.com.cn/aspnet/webpages_intro.asp', 'http://www.w3school.com.cn/aspnet/aspnet_intro.asp'&#125;网站构建万维网联盟 (W3C)浏览器信息网站品质语义网职业规划网站主机网络媒体&#123;'http://www.w3school.com.cn/semweb/index.asp', 'http://www.w3school.com.cn/hosting/index.asp', 'http://www.w3school.com.cn/browsers/index.asp', 'http://www.w3school.com.cn/quality/index.asp', 'http://www.w3school.com.cn/site/index.asp', 'http://www.w3school.com.cn/w3c/index.asp', 'http://www.w3school.com.cn/careers/index.asp', 'http://www.w3school.com.cn/media/index.asp'&#125;# 获取搜索框属性 attrssearch = r.html.find('#searchui &gt; form', first=True)t = search.attrsprint(t)# 输出&#123;'method': 'get', 'id': 'searchform', 'action': 'http://www.google.com.hk/search'&#125; 实战代码撸多了，让我们看会妹纸，以美桌网（ www.win4000.com ）为例，打开网站，观察到这是个列表，图片是缩略图，要想保存图片到本地，当然需要高清大图1234567891011121314151617181920212223242526272829303132from requests_html import HTMLSessionimport requestssession = HTMLSession()# 背景图片地址url = \"http://www.win4000.com/wallpaper_2285_0_10_1.html\"r = session.get(url)# 新建bg文件夹if not os.path.exists('bg'): os.mkdir('bg')# 保存图片到bg/目录def save_image(url, title): img_response = requests.get(url) with open('./bg/'+title+'.jpg', 'wb') as file: file.write(img_response.content)# 查找页面中图片列表，找到链接，# 点击链接，访问查看大图，并获取大图地址pic-largeitems_img = r.html.find('ul.clearfix &gt; li &gt; a')for img in items_img: img_url = img.attrs['href'] if \"/wallpaper_detail\" in img_url: r = session.get(img_url) # 解析图片详情 item_img = r.html.find('img.pic-large', first=True) url = item_img.attrs['src'] # 大图图片地址 title = item_img.attrs['title'] # 图片标题 print(url+title) save_image(url, title)","categories":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sweida.github.io/tags/python/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"https://sweida.github.io/categories/后端/"}]},{"title":"Webpack快速入门","slug":"Webpack快速入门","date":"2018-06-22T17:11:10.000Z","updated":"2018-08-08T03:08:28.530Z","comments":true,"path":"archives/45699.html","link":"","permalink":"https://sweida.github.io/archives/45699.html","excerpt":"","text":"webpack 是什么东西?先看看webpack官网怎么吹牛逼介绍自己的： Webpack 是当下最热门的前端资源模块化 管理和打包 工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分割，等到实际需要的时候再异步加载。 为什要使用webpack现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法 模块化，让我们可以把复杂的程序细化为小的文件; 类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别； Scss，less等CSS预处理器… … 安装12345678910# 全局安装npm install -g webpack# 生成package.json文件,一路回车npm init# 安装到你的项目目录package.json中npm install --save-dev webpack# webpack v4.0以上还需要安装webpack-clinpm install --save-dev webpack-cli Webpack配置文件为webpack.config.js，根目录下新建一个名为webpack.config.js的文件12345678module.exports = &#123; entry: __dirname + \"/app/main.js\", // 已多次提及的唯一入口文件 output: &#123; path: __dirname + \"/build\", // 打包后的文件存放的地方 filename: \"bundle.js\" // 打包后输出文件的文件名 &#125;&#125;// 注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。 在终端执行webpack就会自动引用webpack.config.js文件中的配置选项 在package.json中对scripts对象进行相关设置，即可使用简单的npm build命令来替代上面略微繁琐的命令，设置方法如下的scripts123456789101112131415&#123; \"name\": \"webpack-demo\", \"version\": \"1.0.0\", \"description\": \"\", \"private\": true, \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"webpack\": \"^4.12.0\" &#125;&#125; 使用webpack构建本地服务器想不想让你的浏览器监听你的代码的修改，并自动刷新显示修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖1npm install --save-dev webpack-dev-server 把这些命令加到webpack的配置文件webpack.config.js中12345678910111213141516module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + \"/app/main.js\", // 唯一入口文件 output: &#123; path: __dirname + \"/build\", // 打包后的文件存放的地方 filename: \"bundle.js\" // 打包后输出文件的文件名 &#125; devServer: &#123; contentBase: \"./build\", // 本地服务器所加载的页面所在的目录 historyApiFallback: true, // 不跳转 port: 8000, // 不写默认8080端口 inline: true // 实时刷新 &#125;&#125; 在package.json中的scripts对象中添加如下命令，用以开启本地服务器：12345\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"webpack\", \"server\": \"webpack-dev-server --open\"&#125;, 在终端中输入npm run server即可在本地的8000端口查看结果 Loaders鼎鼎大名的Loaders登场了！ loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 Loaders是webpack提供的最激动人心的功能之一了。通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件。 Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面： 在更高层面，在 webpack 的配置中 loader 有两个目标： test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use 属性，表示进行转换时，应该使用哪个 loader。 webpack.config.js1234567891011121314const path = require('path');const config = &#123; output: &#123; filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.txt$/, use: 'raw-loader' &#125; ] &#125;&#125;;module.exports = config; test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） 插件(plugins)loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要require()它，然后把它添加到plugins数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。 webpack.config.js12345678910111213141516const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const config = &#123; module: &#123; rules: [ &#123; test: /\\.txt$/, use: 'raw-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;;module.exports = config;","categories":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://sweida.github.io/tags/Webpack/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}]},{"title":"Gulp快速入门","slug":"Gulp快速入门","date":"2018-06-21T17:27:40.000Z","updated":"2018-08-08T03:08:28.509Z","comments":true,"path":"archives/23049.html","link":"","permalink":"https://sweida.github.io/archives/23049.html","excerpt":"","text":"gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。 gulp是基于Nodejs的自动任务运行器， 她能自动化地完成 javascript/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。 gulp 和 grunt 非常类似，但相比于 grunt 的频繁 IO 操作，gulp 的流操作，能更快地更便捷地完成构建工作。 全局安装1npm install glup -g 生成package.json文件1npm init # 一路回车 本地安装gulp1npm install glup --save-dev 安装插件123456789# 比较常用的插件npm install --save-dev gulp-concat # （合并文件）npm install --save-dev gulp-copy # （复制文件）npm install --save-dev gulp-clean-css # （压缩css）npm install --save-dev gulp-less # （编译less文件）npm install --save-dev gulp-htmlmin # （压缩html）npm install --save-dev gulp-uglify # （压缩js）npm install --save-dev gulp-useref # （修改html引用css、js路径）npm install --save-dev gulp-livereload # （自动刷新） 打包一个项目的基本配置新建gulpfile.js文件（重要），gulpfile.js是gulp项目的配置文件，是位于项目根目录的普通js文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//导入工具包 require('node_modules里对应模块')var gulp = require('gulp');var less = require('gulp-less');var htmlmin = require('gulp-htmlmin');var cleanCSS = require('gulp-clean-css');var uglify = require('gulp-uglify');var concat = require('gulp-concat');var useref = require('gulp-useref');var copy = require('gulp-copy');// 压缩htmlgulp.task('testHtmlmin', ['testUseref'], function () &#123; // 先修改引用路径，再压缩 var options = &#123; removeComments: true, //清除HTML注释 collapseWhitespace: true, //压缩HTML collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked=\"true\"/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id=\"\" /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true, //删除&lt;script&gt;的type=\"text/javascript\" removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type=\"text/css\" minifyJS: true, //压缩页面JS minifyCSS: true //压缩页面CSS &#125;; return gulp.src('dist/*.html') .pipe(htmlmin(options)) .pipe(gulp.dest('dist'));&#125;);// 复制图片gulp.task('copy', function () &#123; return gulp.src('src/images/**/*') .pipe(gulp.dest('dist/images'));&#125;);// 编译lessgulp.task('testLess', function () &#123; return gulp.src('src/less/*.less') //该任务针对的文件 .pipe(less()) //该任务调用的模块 .pipe(gulp.dest('src/css')); //将会在src/css下生成index.css&#125;);// 压缩cssgulp.task('testCssmin', ['testLess'], function () &#123; // 先执行testLess任务后再执行cssmin任务，必须加上rutrun才能异步 return gulp.src('src/css/*.css') .pipe(concat('libs.min.css')) // 先合并css后再压缩 .pipe(cleanCSS()) .pipe(gulp.dest('dist/css'));&#125;);// 压缩jsgulp.task('jsmin', function () &#123; return gulp.src('src/js/*.js') .pipe(concat('libs.min.js')) // 先合并js后再压缩 .pipe(uglify()) .pipe(gulp.dest('dist/js'));&#125;);// 修改html的引用地址gulp.task('testUseref', function () &#123; return gulp.src('src/*.html') .pipe(useref()) .pipe(gulp.dest('dist'));&#125;);// watch暂时先不启动// // watch监听less文件 自动执行less编辑后压缩// gulp.task('watchLess', function () &#123;// gulp.watch('src/less/*.less', ['testCssmin']);// &#125;);//// // watch监听js，有更改就输出log// gulp.task('watchJs', function () &#123;// gulp.watch('src/js/*.js', function (event) &#123;// console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');// &#125;);// &#125;);// 执行定义任务gulp.task('default',[ 'copy', 'jsmin', 'testCssmin', 'testHtmlmin' // 'watchLess', // 'watchJs']); 运行gulp编译less：命令提示符执行:1234# 全部运行gulp# 运行指定模块gulp testLess 打包后生成的文件目录dist 最后还差一步，引用css、js自动添加版本号，找了很多资料，没有一个能很好解决 项目地址： https://github.com/sweida/gulp-demo","categories":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}],"tags":[{"name":"Gulp","slug":"Gulp","permalink":"https://sweida.github.io/tags/Gulp/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}]},{"title":"Grunt快速入门","slug":"Grunt快速入门","date":"2018-06-21T01:16:25.000Z","updated":"2018-08-08T03:08:28.505Z","comments":true,"path":"archives/12322.html","link":"","permalink":"https://sweida.github.io/archives/12322.html","excerpt":"","text":"前言各位web前端开发人员，如果你现在还不知道grunt或者听说过但是不会熟练使用grunt，那你就真的真的真的out了。还有一点，它完全免费，没有盗版。既强大又免费的东西，为何不用？ 当然了，你如果你能找到更好的替代grunt的其他工具也是可以的，例如gulp。Gulp未来有可能替代grunt，但是现在来说市场占有率还是不如grunt。而这种工具咱们是现在就需要用的，所有不要再犹豫了，拿来主义，先用grunt，即学即用。 Grunt是一套前端自动化工具，一个基于nodeJs的命令行工具，最基本的用法有： 压缩文件 合并文件 简单语法检查 文章底部附带项目的github地址 安装 CLI1npm install -g grunt-cli 安装grunt-cli并不等于安装了 Grunt！Grunt CLI的任务很简单：调用与Gruntfile在同一目录中 Grunt。 开始使用grunt很简单，在项目的根目录中添加两份文件：package.json 和 Gruntfile.js。 12345678&#123; \"name\": \"grunt_demo\", \"version\": \"1.0.0\", \"description\": \"A grunt project\", \"author\": \"sweida &lt;weida@ifm360.cn&gt;\", \"devDependencies\": &#123; &#125;&#125; devDependencies是什么意思？字面意思解释是“开发依赖项”。即我们现在这个系统，将会依赖于哪些工具来开发。现在代码一行都没有写，依赖于谁？谁也不依赖！所以，就先写一个空对象。但是下文会慢慢把它填充起来。 安装Grunt下面这条命令将安装Grunt最新版本到项目目录中，并将其添加到package.json中的devDependencies内：1npm install grunt --save-dev 安装后package.json123456789&#123; \"name\": \"grunt_demo\", \"version\": \"1.0.0\", \"description\": \"A grunt project\", \"author\": \"sweida &lt;weida@ifm360.cn&gt;\", \"devDependencies\": &#123; \"grunt\": \"^1.0.2\" &#125;&#125; 项目代码目录结构如下 插件合并：grunt-contrib-concat安装如下（下面插件同样方法）1npm install grunt-contrib-concat --save-dev 合并代码是我们最需要的一个功能了，当项目变大并且模块很多的时候，随便拿一个项目来说，index页面会有一列的js代码，如下图所示：1234&lt;script src=\"./js/jquery-1.10.1.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery.edslider.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/swiper.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/common.js\"&gt;&lt;/script&gt; 我们需要将这些css、js合并为一个文件，大大减少网络请求数量因此来提升性能。grunt-contrib-concat完美胜任，下面我们来看看基本配置用法：12345678910111213141516171819202122// Gruntfile.js文件module.exports = function(grunt) &#123; // 任务配置，所有插件的配置信息 grunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'), concat: &#123; cssConcat:&#123; src:['src/css/*.css'], dest:'dist/css/&lt;%= pkg.name %&gt; - &lt;%= grunt.template.today(\"yyyy-mm-dd\") %&gt;.css' //dest 是目的地输出 &#125;, jsConcat:&#123; src:'src/js/*.js', dest:'dist/js/&lt;%= pkg.name %&gt;.js' &#125; &#125;, &#125;); // 告诉grunt 我们将要使用的插件 grunt.loadNpmTasks('grunt-contrib-concat'); // 告诉grunt 我们在终端输入grunt时需要做些什么（注意先后顺序） grunt.registerTask('default', ['concat']);&#125;; 将src中所有css、js文件合并为一个，放在dist目录下，名字为package.json配置中项目name。如下所示： 压缩：grunt-contrib-uglify和grunt-contrib-cssmin合并文件后，体积仍然比较大，上线之前要将代码压缩，因此我们接着将上一步合并后的代码压缩，这里就需要用到grunt-contrib-uglify和grunt-contrib-cssmin插件。在使用grunt-contrib-uglify插件之前如果有用es6语法，需要将es6语法用babel转成es5才能正常压缩 1234# 安装压缩npm install --save-dev grunt-contrib-uglify grunt-contrib-cssmin# 安装babelnpm install --save-dev grunt-babel babel-preset-env babel-core 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061module.exports = function(grunt) &#123; grunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'), concat: &#123; cssConcat:&#123; src:['src/css/*.css'], dest:'dist/css/&lt;%= pkg.name %&gt; - &lt;%= grunt.template.today(\"mm-dd\") %&gt;.css' //dest 是目的地输出 &#125;, jsConcat:&#123; src:'src/js/*.js', dest:'dist/js/&lt;%= pkg.name %&gt;.js' &#125; &#125;, babel: &#123; options: &#123; sourceMap: true, presets: ['env'] &#125;, dist: &#123; files: [&#123; expand:true, cwd: 'dist', //js目录下 src: '**/&lt;%= pkg.name %&gt;.js', //所有js文件 dest: 'dist' //输出到此目录下 &#125;] &#125; &#125;, cssmin:&#123; options:&#123; banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(\"mm-dd\") %&gt; */\\n' &#125;, build:&#123; src:'dist/css/*.css',//压缩是要压缩合并了的 dest:'dist/css/&lt;%= pkg.name %&gt; - &lt;%= grunt.template.today(\"mm-dd\") %&gt;.min.css' //dest 是目的地输出 &#125; &#125;, uglify: &#123; options: &#123; banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(\"yyyy-mm-dd\") %&gt; */\\n' // 在文件头部添加压缩时间 &#125;, build: &#123; src: 'dist/js/&lt;%= pkg.name %&gt;.js', //所在js文件 dest: 'dist/js/&lt;%= pkg.name %&gt;.min.js' //输出到此目录下 &#125; &#125; &#125;); // 告诉grunt 我们将要使用的插件 grunt.loadNpmTasks('grunt-contrib-concat'); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-cssmin'); grunt.loadNpmTasks('grunt-babel'); // 告诉grunt 我们在终端输入grunt时需要做些什么（注意先后顺序） grunt.registerTask('default', [ 'concat', 'cssmin', 'babel', 'uglify' ]);&#125;;&#125;; 这里我将concat后的js文件仍然输出到当前目录dest/js下，多个了min.js，如下图所示： 引用替换：grunt-usemin、grunt-contrib-copy、grunt-contrib-clean前端优化是尽量减少http请求，所以我们需要尽量合并压缩文件，然后调用压缩后的文件，比如多个css文件压缩成一个，多个js文件合并压缩等，grunt-usemin能够自动在html中使用压缩后的文件，达到上面的目的。 因此首先我们需要用到grunt-contrib-copy插件，将源代码copy一份，然后在副本上进行压缩合并，这样无论是全部压缩还是部分压缩就比较灵活了，copy之后就可以使用grunt-usemin插件了，usemin是一个多任务插件，它包括两个任务，useminPrepare和usemin。 useminPrepare用来检测html页面中的脚本块，包括脚本文件的源路径，目的路径，从而更新后续需要使用到的Grunt任务的配置信息，如前面使用的concat，uglify。useminPrepare只是分析文件，获取文件及路径信息，不更新内容。 而usemin则进行文件引用替换，将源文件中的文件块替换为压缩文件。useminPrepare已经帮助我们自动配置了concat，uglify针对的源文件以及目的文件的路径信息,因此就无需再手动配置concat和uglify任务了。配置代码如下123456&lt;!-- build:css css/grunt_demo.min.css --&gt;&lt;script src=\"./js/jquery-1.10.1.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery.edslider.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/swiper.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/common.js\"&gt;&lt;/script&gt;&lt;!-- endbuild --&gt; 注意js需要&lt;!-- build:css css/App.min.css --&gt;&lt;!-- endbuild --&gt;这样包裹着usemin才能起效1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162module.exports = function(grunt) &#123; grunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'), clean: &#123; src: 'build/' &#125;, useminPrepare: &#123; html: 'build/index.html', options: &#123; dest: 'build' &#125; &#125;, cssmin: &#123; buildrelease: &#123; options: &#123; report: \"min\" //输出压缩率 &#125; &#125; &#125;, uglify: &#123; buildrelease: &#123; options: &#123; report: \"min\" //输出压缩率 &#125; &#125; &#125;, usemin: &#123; html: 'build/index.html', options: &#123; dest: 'build' &#125; &#125;, copy: &#123; html: &#123; files: [&#123; expand: true, cwd: 'src', src: '**/*', dest: 'build/' &#125;] &#125; &#125; &#125;); // 告诉grunt 我们将要使用的插件 grunt.loadNpmTasks('grunt-contrib-concat'); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-cssmin'); grunt.loadNpmTasks('grunt-contrib-clean'); grunt.loadNpmTasks('grunt-contrib-copy'); grunt.loadNpmTasks('grunt-usemin'); // 告诉grunt 我们在终端输入grunt时需要做些什么（注意先后顺序） grunt.registerTask('default', [ 'clean', 'copy', 'useminPrepare', 'concat', 'cssmin', 'uglify', 'usemin' ]);&#125;; 上面又引入了一个clean插件，每次构建时候先清除build目录，这样build目录就是我们打包后的要的结果了。目录结构如下： 项目地址： https://github.com/sweida/grunt-demo","categories":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}],"tags":[{"name":"Grunt","slug":"Grunt","permalink":"https://sweida.github.io/tags/Grunt/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}]},{"title":"理解Gulp和Webpack","slug":"理解Gulp和Webpack","date":"2018-06-21T00:54:35.000Z","updated":"2018-08-08T03:08:28.537Z","comments":true,"path":"archives/30083.html","link":"","permalink":"https://sweida.github.io/archives/30083.html","excerpt":"","text":"Gulp 为何物？先来听听 Ta 的官网是怎么说： Gulp 致力于 自动化和优化 你的工作流，它是一个自动化你开发工作中 痛苦又耗时任务 的工具包。 Gulp 就是为了规范前端开发流程，实现前后端分离、模块化开发、版本控制、文件合并与压缩、mock数据等功能的一个前端自动化构建工具。说的形象点，“Gulp就像是一个产品的流水线，整个产品从无到有，都要受流水线的控制，在流水线上我们可以对产品进行管理 webpack 又是什么东西?老规矩，先看看webpack官网怎么吹牛逼介绍自己的： Webpack 是当下最热门的前端资源模块化 管理和打包 工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分割，等到实际需要的时候再异步加载。 单页应用的核心是模块化，ES6 之前 JavaScript 语言本身一直是没有模块系统的，导致 AMD，CMD，UMD 各种轮子模块化方案都蹦出来。对这种模块化乱象，gulp 显得无能为力，gulp 插件对这一块也没有什么想法。不过也可以理解，模块化解决方案可不是谁都能 hold 住的，需要考虑的问题太多了；对前沿的 SPA 技术 gulp 处理起来显得有些力不从心，例如 Vue 的单文件组件，gulp 配合一些插件可以勉强处理，但是很蹩脚。其实归根结底，还是模块化处理方面的不足；优化页面加载速度的一条重要法则就是减少 http 请求。gulp 只是对静态资源做流式处理，处理之后并未做有效的优化整合，也就是说 gulp 忽略了系统层面的处理，这一块还有很大的优化空间，尤其是移动端，那才真的是一寸光阴一寸金啊，哪怕是几百毫秒的优化所带来的收益（用户？流量？付费？）绝对超乎你的想象。别跟我说 gulp-concat，CSS Sprites，这俩玩意儿小打小闹还行，遇上大型应用根本拿不上台面。现在的页面动辄上百个零碎资源（图片，样式表，脚本），也就是上百个 http 请求，因此这个优化需求还是相当迫切的。关于为何减少 http 请求可以有效降低页面加载时间戳这里。 首先从概念上可以看出，Gulp和Webpack的侧重点是不同的。 Gulp 是基于流的？流（Stream）不是 gulp 创造的概念，而是从 unix 时代就开始使用的 I/O 机制，一直到现在仍在广泛使用。Node 封装了一个 stream 模块专门用来对流进行操作。gulp 所基于的流即是 Node 封装起来的 stream。上面 gulp.task() 代码里面的 pipe 方法并不是 gulp 提供的 api，而是 node 的 api，准确的说应该是 node 的 stream 模块提供的 api。具体是怎么实现的呢：gulp.src() 的返回值是 node Stream 的一个实例，之后的 pipe 调用的其实是这个实例的 pipe 方法，而 pipe 方法的返回值依然是 node Stream 实例，以此实现前面的 .pipe().pipe().pipe() 这种串联写法。熟悉 jQuery 的同学应该很清楚这种技巧。 webpack 怎么实现像 gulp 一样对大量源文件进行流式处理?人家 webpack 本来就没打算做这事。webpack 不是以取代 gulp 为目的的，而是为了给大型 SPA 提供更好的构建方案。对大量源文件进行流式处理是 gulp 擅长的事，webpack 不想抢，也没必要抢。即使抢，也无非是再造一个蹩脚的 gulp 出来而已。 既然 webpack 模块化这么强，那以后模块化就全用 webpack 好了?webpack 模块化是强，但是他胖啊，不是所有人都抱得动，主要是他为了提供更多的功能封装进了太多东西，所以选择上还是需要因地制宜。如果单纯只是打包 js（多页应用往往是这种需求），完全可以使用 rollup，browserify 这种小而美的实现，因为他们只做一件事——打包js。而如果需要将图片，样式，字体等所有静态资源全部打包，webpack 毫无疑问是首选。这也是为什么越来越多的流行库和框架开始从 webpack 转向使用 rollup 进行打包，因为他们只需要打包 js，webpack 好多强大功能根本用不到。连 rollup 官网也坦言如果你在构建一个库，rollup 绝对是首选，但如果是构建一个应用，那么请选 webpack。 下表是从各个角度对 gulp 和 webpack 做的对比： – Gulp Webpack 定位 基于流的自动化构建工具 一个万能模块打包器 目标 自动化和优化开发工作流，为通用 website 开发而生 通用模块打包加载器，为移动端大型 SPA 应用而生 学习难度 易于学习，易于使用，api总共只有5个方法 有大量新的概念和api，不过好在有详尽的官方文档 适用场景 基于流的作业方式适合多页面应用开发 一切皆模块的特点适合单页面应用开发 工作方式 对输入（gulp.src）的 js，ts，scss，less 等源文件依次执行打包（bundle）、编译（compile）、压缩、重命名等处理后输出（gulp.dest）到指定目录中去，为了构建而打包 对入口文件（entry）递归解析生成依赖关系图，然后将所有依赖打包在一起，在打包之前会将所有依赖转译成可打包的 js 模块，为了打包而构建 使用方式 常规 js 开发，编写一系列构建任务（task） 编辑各种 JSON 配置项 优点 适合多页面开发，易于学习，易于使用，接口优雅 可以打包一切资源，适配各种模块系统 缺点 在单页面应用方面输出乏力，而且对流行的单页技术有些难以处理（比如 Vue 单文件组件，使用 gulp 处理就会很困难，而 webpack 一个 loader 就能轻松搞定） 不适合多页应用开发，灵活度高但同时配置很繁琐复杂。“打包一切” 这个优点对于 HTTP/1.1 尤其重要，因为所有资源打包在一起能明显减少浏览器访问页面时的资源请求数量，从而减少应用程序必须等待的时间。但这个优点可能会随着 HTTP/2 的流行而变得不那么突出，因为 HTTP/2 的多路复用可以有效解决客户端并行请求时的瓶颈问题。 结论 浏览器多页应用(MPA)首选方案 浏览器单页应用(SPA)首选方案","categories":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}],"tags":[{"name":"Gulp","slug":"Gulp","permalink":"https://sweida.github.io/tags/Gulp/"},{"name":"Webpack","slug":"Webpack","permalink":"https://sweida.github.io/tags/Webpack/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}]},{"title":"markdown代码块支持高亮显示的语言","slug":"markdown代码块支持高亮显示的语言","date":"2018-06-20T15:59:04.000Z","updated":"2018-08-08T03:08:28.533Z","comments":true,"path":"archives/633.html","link":"","permalink":"https://sweida.github.io/archives/633.html","excerpt":"","text":"markdown里对代码块的引用语法是三个撇[ ``` ],在其后可增加代码名称,比如java,js等标记该部分代码的类型.之后在页面展现的时候就可以高亮显示关键字了. 比如下面这段代码: ```javascriptvar xiaoming = {&nbsp;&nbsp;name: ‘小明’,&nbsp;&nbsp;birth: 1990,&nbsp;&nbsp;age: function () {&nbsp;&nbsp;&nbsp;&nbsp;var y = new Date().getFullYear();&nbsp;&nbsp;&nbsp;&nbsp;return y - this.birth;&nbsp;&nbsp;}};``` 12345678var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;; 整理了一下表格,看看markdown到底支持多少种语言高亮显示. 名称 关键字 JavaScript js , jscript , javascript Java java PHP php text text , plain Python py , python Shell bash , shell C cpp , c C# c# , c-sharp , csharp CSS css XML xml , xhtml , xslt , html SASS&amp;SCSS sass , scss Scala scala SQL sql Visual Basic vb , vbnet Objective C objc , obj-c Ruby ruby , rails , ror , rb AppleScript applescript ColdFusion coldfusion , cf Delphi delphi , pascal , pas diff&amp;patch diff patch Erlang erl , erlang Groovy groovy JavaFX jfx , javafx Perl perl , pl , Perl F# f# f-sharp , fsharp R r , s , splus matlab matlab swift swift GO go , golang","categories":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://sweida.github.io/tags/markdown/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}]},{"title":"JavaScript的闭包问题","slug":"JavaScript的闭包问题","date":"2018-06-20T03:01:05.000Z","updated":"2018-08-08T03:08:28.513Z","comments":true,"path":"archives/23155.html","link":"","permalink":"https://sweida.github.io/archives/23155.html","excerpt":"","text":"JavaScript是一种非常强大的函数式编程语言，可以动态创建函数对象。 由于JavaScript还支持闭包（Closure），因此，函数可以引用其作用域外的变量，非常强大。 来看看在JavaScript中使用闭包的陷阱： 123456789101112var tasks = [];for (var i=0; i&lt;3; i++) &#123; tasks.push(function() &#123; console.log('&gt;&gt;&gt; ' + i); &#125;);&#125;console.log('end for.');for (var j=0; j&lt;tasks.length; j++) &#123; tasks[j]();&#125; 如果在循环中创建函数，并引用循环变量，原意是打印出0，1，2，但结果却是一样的： 1234end for.&gt;&gt;&gt; 3&gt;&gt;&gt; 3&gt;&gt;&gt; 3 这个问题的原因在于，函数创建时并未执行，所以先打印end for.，然后才执行函数。 由于函数引用了循环变量i，在函数执行时，由于i的值已经变成了3，所以，打印出的结果不对。 如果我们用一个变量n来复制一份i传入呢？ 1234567891011121314var tasks = [];for (var i=0; i&lt;3; i++) &#123; var n = i; tasks.push(function() &#123; console.log('&gt;&gt;&gt; ' + n); &#125;);&#125;console.log('end for.');for (var j=0; j&lt;tasks.length; j++) &#123; tasks[j]();&#125; 结果还是不对： 1234end for.&gt;&gt;&gt; 2&gt;&gt;&gt; 2&gt;&gt;&gt; 2 注意到i会比n多加一次，所以n的最终值是2。 这个问题的原因是JavaScript虽然有局部变量，但局部变量只有函数作用域，而没有其他语言通常有的块作用域（循环内部，if内部），所以，无论在函数内部的哪个地方定义变量，变量作用域都是整个函数。 把上述代码的变量提取到函数开头，其实是这样的： 12345678910111213141516var tasks, i, n, j;tasks = [];for (i=0; i&lt;3; i++) &#123; n = i; tasks.push(function() &#123; console.log('&gt;&gt;&gt; ' + n); &#125;);&#125;console.log('end for.');for (j=0; j&lt;tasks.length; j++) &#123; tasks[j]();&#125; 完全等价。 根据道爷的说法，JavaScript缺少块作用域是语言设计的一个缺陷。所以，上面的代码有问题，就是因为n的作用域是整个函数，而不是循环。 创建闭包的一条原则就是：不要引用循环变量！这条原则对有没有块作用域的函数式编程语言都适用。如果一定要在闭包中引用循环变量怎么办？？？ 方法是再创建一个函数，将循环变量作为函数参数传入： 12345678910var tasks = [];for (var i=0; i&lt;3; i++) &#123; var fn = function(n) &#123; tasks.push(function() &#123; console.log('&gt;&gt;&gt; ' + n); &#125;); &#125;; fn(i);&#125; 这段代码是正确的，是因为循环内部，fn()函数立即被执行，因此，闭包拿到的参数n就是当前循环变量的值的副本。 最后，简化语法，直接用匿名函数的立即执行模式(function() { … })()改写如下： 123456789var tasks = [];for (var i=0; i&lt;3; i++) &#123; (function(n) &#123; tasks.push(function() &#123; console.log('&gt;&gt;&gt; ' + n); &#125;); &#125;)(i);&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sweida.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"hexo-abbrlink介绍","slug":"hexo-abbrlink介绍","date":"2018-06-15T17:50:03.000Z","updated":"2018-08-08T03:08:28.530Z","comments":true,"path":"archives/58183.html","link":"","permalink":"https://sweida.github.io/archives/58183.html","excerpt":"","text":"前言hexo的地址默认提供的方案是使用年/月/日/标题，这简直反人类啊，写博客的标题是中文，中文的网址给我带来了许多麻烦。那要怎么优化地址呢？ 需求 全自动生成唯一连接 重复生成不会覆盖 尽量短小精悍 持久保存可供修改 不引用外部模块 最优方案对标题+时间进行md5然后再转base64，保存在front-matter中。 实现首先是注册before_post_render钩子，然后取出来abbrlink这个属性看是否存在，存在的就不管了，否则就生成连接。其中使用了nodejs自带的crypto模块来获取md5校验值，用hexo-front-matter来转换front-matter，然后用hexo-fs来保存文件。 安装1npm install hexo-abbrlink --save 使用打开根目录_config.yml文件，修改permalink中类似这样1permalink: posts/:abbrlink/ 其中:abbrlink代表连接地址。 posts为你想要使用的地址目录 最终用 hexo new xxxx 生成新博文时就会自动在.md里多生成一行 (项目需要hexo serve启动) posts: 12345（一串数字） 然后博文地址就变成 xxxx.github.io/posts/12345.html","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://sweida.github.io/tags/hexo/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"删除github上远程的分支","slug":"删除github上远程的分支","date":"2018-06-15T07:37:56.000Z","updated":"2018-08-08T03:08:28.536Z","comments":true,"path":"archives/26064.html","link":"","permalink":"https://sweida.github.io/archives/26064.html","excerpt":"","text":"如果想删除github上的source分支,通过下面命令推送一个空分支到远程分支，其实就相当于删除远程分支1git push origin :source 如图 切换并新建分支1git checkout -b dev 它是下面两条命令的简写，新建分支，然后切换分支12git branch devgit checkout dev","categories":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://sweida.github.io/tags/Git/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}]},{"title":"HTML5存储使用详解（本地存储、会话存储）","slug":"HTML5存储使用详解（本地存储、会话存储）","date":"2018-06-15T03:44:02.000Z","updated":"2018-08-08T03:08:28.511Z","comments":true,"path":"archives/13671.html","link":"","permalink":"https://sweida.github.io/archives/13671.html","excerpt":"","text":"1，Web存储介绍HTML5的Web存储功能是让网页在用户计算机上保存一些信息。Web存储又分为两种：（1）本地存储，对应 localStorage 对象。用于长期保存网站的数据，并且站内任何页面都可以访问该数据。（2）会话存储，对应 sessionStorage 对象。用于临时保存针对一个窗口（或标签页）的数据。在访客关闭窗口或者标签页之前，这些数据是存在的，而关闭之后就会被浏览器删除。 2，本地存储与会话存储的异同（1）本地存储和会话存储的操作代码完全相同，它们的区别仅在于数据的寿命。（2）本地存储主要用来保存访客将来还能看到的数据。（3）会话存储则用于保存那些需要从一个页面传递给下一个页面的数据。 3，Web存储容量限制大多数浏览器都把本地存储限制为 5MB 以下。这个是和网站所在的域联系在一起的。 4，Web存储的使用样例下面以本地存储（localStorage）为例，会话存储改成 sessionStorage 对象即可。 （1）文本数据的保存和读取12localStorage.setItem(\"user_name\",\"hangge.com\");var userName = localStorage.getItem(\"user_name\"); （2）数值的保存和读取12localStorage.setItem(\"user_age\",100);var userAge = Number(localStorage.getItem(\"user_age\")); （3）日期的保存和读取12345678910//创建日期对象var today = new Date();//按照YYY/MM/DD的标准格式把日期转换成文本字符串，然后保存为文本var todayString = today.getFullYear() + \"/\" + today.getMonth() + \"/\" + today.getDate();localStorage.setItem(\"session_started\", todayString);//取得日期文本，并基于该文本创建新的日期对象var newToday = new Date(localStorage.getItem(\"session_started\"));alert(newToday.getFullYear()); （4）自定义对象的保存和读取对象的保存和读取可以通过JSON编码转换来实现。JSON.stringify()：把任何对象连同其数据转换为文本形似。JSON.parse()：把文本转换回对象。123456789101112131415161718//自定义一个User对象function User(n, a, t) &#123; this.name = n; this.age = a; this.telephone = t;&#125;//创建User对象var user = new User(\"hangge\", 100, \"123456\");//将其保存为方便的JSON格式sessionStorage.setItem(\"user\", JSON.stringify(user));//跳转页面//window.location = \"hangge.html\";//将JSON文本转回原来的对象var user2 = JSON.parse(sessionStorage.getItem(\"user\"));alert(user2.name); （5）检测某个键的值是否为空，可以直接测试是否等于null123if(localStorage.getItem(\"user_name\") == null)&#123; alert(\"用户名不存在！\");&#125; （6）删除数据项1localStorage.removeItem(\"user_name\"); （7）清除所有数据1localStorage.clear(); （8）查找所有的数据项不知道键名，可以使用 key() 方法从本地或者会话存储中取得所有的数据项。下面样例，点击按钮后就会列出所有本地存储中的数据。123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Find All Items&lt;/title&gt; &lt;script&gt; function findAllItems() &#123; //取得用于保存数据项的&lt;ul&gt;元素 var itemList = document.getElementById(\"itemList\"); //清除列表 itemList.innerHTML = \"\"; //遍历所有数据项 for (var i=0; i&lt;localStorage.length; i++) &#123; //取得当前位置数据项的键 var key = localStorage.key(i); //取得以该键保存的数据值 var item = localStorage.getItem(key); //用以上数据创建一个列表项添加到页面中 var newItem = document.createElement(\"li\"); newItem.innerHTML = key + \": \" + item; itemList.appendChild(newItem); &#125; &#125; &lt;/script&gt;&lt;body&gt; &lt;button onclick=\"findAllItems()\"&gt;导出所有本地存储数据&lt;/button&gt; &lt;ul id=\"itemList\"&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 5，响应存储变化Web存储也为我们提供了在不同浏览器窗口间通信的机制。也就是说在本地存储或会话存储发生变化时，其他查看同一页面或者同一站点中其他页面的窗口就会触发 window.onStorage 事件。这里说的存储变化，指的是向存储中添加新数据项，修改既有数据项，删除数据项或者清除所有数据。而对存储不产生任何影响的操作（用既有键名保存相同的值，或者清除原本就是空的存储空间），不会引发onStorage 事件。","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://sweida.github.io/tags/HTML5/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"三张图搞懂JavaScript的原型对象与原型链","slug":"三张图搞懂JavaScript的原型对象与原型链","date":"2018-06-15T03:31:41.000Z","updated":"2018-08-08T03:08:28.536Z","comments":true,"path":"archives/16268.html","link":"","permalink":"https://sweida.github.io/archives/16268.html","excerpt":"","text":"对于新人来说，JavaScript的原型是一个很让人头疼的事情，一来prototype容易与proto混淆，二来它们之间的各种指向实在有些复杂，其实市面上已经有非常多的文章在尝试说清楚，有一张所谓很经典的图，上面画了各种线条，一会连接这个一会连接那个，说实话我自己看得就非常头晕，更谈不上完全理解了。所以我自己也想尝试一下，看看能不能把原型中的重要知识点拆分出来，用最简单的图表形式说清楚。 我们知道原型是一个对象，其他对象可以通过它实现属性继承。但是尼玛除了prototype，又有一个proto是用来干嘛的？长那么像，让人怎么区分呢？它们都指向谁，那么混乱怎么记啊？原型链又是什么鬼？相信不少初学者甚至有一定经验的老鸟都不一定能完全说清楚，下面用三张简单的图，配合一些示例代码来理解一下。1234567var a = &#123;&#125;;console.log(a.prototype); //undefinedconsole.log(a.__proto__); //Object &#123;&#125;var b = function()&#123;&#125;console.log(b.prototype); //b &#123;&#125;console.log(b.__proto__); //function() &#123;&#125; 12345678910111213141516171819/*1、字面量方式*/var a = &#123;&#125;;console.log(a.__proto__); //Object &#123;&#125;console.log(a.__proto__ === a.constructor.prototype); //true/*2、构造器方式*/var A = function()&#123;&#125;;var a = new A();console.log(a.__proto__); //A &#123;&#125;console.log(a.__proto__ === a.constructor.prototype); //true/*3、Object.create()方式*/var a1 = &#123;a:1&#125;var a2 = Object.create(a1);console.log(a2.__proto__); //Object &#123;a: 1&#125;console.log(a.__proto__ === a.constructor.prototype); //false（此处即为图1中的例外情况） 12345var A = function()&#123;&#125;;var a = new A();console.log(a.__proto__); //A &#123;&#125;（即构造器function A 的原型对象）console.log(a.__proto__.__proto__); //Object &#123;&#125;（即构造器function Object 的原型对象）console.log(a.__proto__.__proto__.__proto__); //null","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sweida.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"Gitment：使用 GitHub Issues 搭建评论系统","slug":"使用 GitHub Issues 搭建评论系统","date":"2018-06-14T09:16:55.000Z","updated":"2018-08-08T03:08:28.536Z","comments":true,"path":"archives/53055.html","link":"","permalink":"https://sweida.github.io/archives/53055.html","excerpt":"","text":"Gitment 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 本博客评论系统已迁移至 Gitment。虽然 Gitment 只能使用 GitHub 账号进行评论，但考虑到博客受众，这是可以接受的。","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"Gitment","slug":"Gitment","permalink":"https://sweida.github.io/tags/Gitment/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"手机访问PC网站自动跳转到手机版","slug":"手机访问PC网站自动跳转到手机版","date":"2018-06-14T09:03:57.000Z","updated":"2018-08-08T03:08:28.536Z","comments":true,"path":"archives/34869.html","link":"","permalink":"https://sweida.github.io/archives/34869.html","excerpt":"","text":"手机访问PC网站自动跳转到手机版，在body下面添加下面代码1234567891011&lt;script type=\"text/javascript\"&gt; try &#123; var urlhash = window.location.hash if (!urlhash.match('fromapp')) &#123; if (navigator.userAgent.match(/(iPhone|iPod|Android|ios|iPad)/i)) &#123; window.location = '你的手机版地址' &#125; &#125; &#125; catch (err) &#123;&#125;&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sweida.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"Javascript中数组的迭代方法","slug":"Javascript中数组的迭代方法","date":"2018-04-11T15:07:10.000Z","updated":"2018-08-08T03:08:28.514Z","comments":true,"path":"archives/16016.html","link":"","permalink":"https://sweida.github.io/archives/16016.html","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sweida.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"Vue.js的生命周期详解","slug":"Vue.js的生命周期详解","date":"2017-11-07T17:47:17.000Z","updated":"2018-08-08T03:08:28.528Z","comments":true,"path":"archives/26037.html","link":"","permalink":"https://sweida.github.io/archives/26037.html","excerpt":"","text":"Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列 过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。 在Vue的整个生命周期中，它提供了一些生命周期钩子，给了我们执行自定义逻辑的机会。 它可以总共分为8个阶段：12345678beforeCreate（创建前）,created（创建后）,beforeMount(载入前),mounted（载入后）,beforeUpdate（更新前）,updated（更新后）,beforeDestroy（销毁前）,destroyed（销毁后） 接下来我们用例子来看看生命周期钩子是怎么用的，HTML结构：12345&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input type=\"text\" v-model=\"message\"&gt; &lt;button v-on:click=\"change\"&gt;改变数据&lt;/button&gt;&lt;/div&gt; 我们对 input 和 p 绑定了data 对象的 message 数据，Vue 实例构建如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var app = new Vue(&#123; el: \"#app\", data: &#123; message: \"hello world\" &#125;, beforeCreate: function() &#123; console.log(\"创建前\") console.log(this.message) console.log(this.$el) &#125;, created: function() &#123; console.log(\"创建之后\"); console.log(this.message) console.log(this.$el) &#125;, beforeMount: function() &#123; console.log(\"mount之前\") console.log(this.message) console.log(this.$el) &#125;, mounted: function() &#123; console.log(\"mount之后\") console.log(this.message) console.log(this.$el) &#125;, beforeUpdate: function() &#123; console.log(\"更新前\"); console.log(this.message) console.log(this.$el) &#125;, updated: function() &#123; console.log(\"更新完成\"); console.log(this.message); console.log(this.$el) &#125;, beforeDestroy: function() &#123; console.log(\"销毁前\"); console.log(this.message) console.log(this.$el) console.log(this.$el) &#125;, destroyed: function() &#123; console.log(\"已销毁\"); console.log(this.message) console.log(this.$el) &#125; &#125;) 然后在 methods 里面添加一个change方法：12345methods: &#123; change :function() &#123; this.message = \"vue.js\" &#125; &#125; 点击按钮之后出现的是： 这就是vue的生命周期，很简单吧。 在实例中分别在每个生命周期钩子中console.log(&#39;钩子名称&#39;,this.message)我们发现，第一次页面加载时触发了 beforeCreate, created, beforeMount, mounted这几个钩子，data 数据在 created 中可获取到。再去console.log(&#39;mounted: &#39;, document.getElementsByTagName(&#39;p&#39;)[0]) ，DOM 渲染在 mounted 中已经完成。 我们再试着去点击按钮更改 message 和 input 输入框中的内容，可以看到数据同步发生改变，这就是数据绑定的效果，在更新数据时触发 beforeUpdate 和 updated 钩子，且在 beforeUpdate 触发时，数据已更新完毕。 而 destroy 仅在调用app.$destroy()时触发，对 vue 实例进行销毁。销毁完成后，我们再重新改变 number 的值，vue 不再对此动作进行响应了。但是原先生成的dom元素还存在，可以这么理解，执行了destroy操作，后续就不再受vue控制了。 生命周期小结生命周期钩子的一些使用方法：123456beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用mounted : 挂载元素，获取到DOM节点updated : 如果对数据统一处理，在这里写上相应函数beforeDestroy : 可以做一个确认停止事件的确认框nextTick : 更新数据后立即操作dom","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://sweida.github.io/tags/vue/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"Javascript里的this","slug":"javascript里的this","date":"2017-08-15T03:37:27.000Z","updated":"2018-08-08T03:08:28.531Z","comments":true,"path":"archives/19315.html","link":"","permalink":"https://sweida.github.io/archives/19315.html","excerpt":"","text":"在一个对象中绑定函数，称为这个对象的方法。 在JavaScript中，对象的定义是这样的： 1234var xiaoming = &#123; name: '小明', birth: 1990&#125;; 但是，如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄： 1234567891011var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;xiaoming.age; // function xiaoming.age()xiaoming.age(); // 今年调用是25,明年调用就变成26了 绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？ 在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。 让我们拆开写： 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25, 正常结果getAge(); // NaN 单独调用函数getAge()怎么返回了NaN？请注意，我们已经进入到了JavaScript的一个大坑里。 JavaScript的函数内部如果调用了this，那么这个this到底指向谁？ 答案是，视情况而定！ 如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming，这是符合我们预期的。 如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。 坑爹啊！ 更坑爹的是，如果这么写：12var fn = xiaoming.age; // 先拿到xiaoming的age函数fn(); // NaN 也是不行的！要保证this指向正确，必须用obj.xxx()的形式调用！ 12345678910111213141516'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 25 用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。apply 虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！ 要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 用apply修复getAge()调用：12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 另一个与apply()类似的方法是call()，唯一区别是： apply()把参数打包成Array再传入； call()把参数按顺序传入。","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sweida.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"vue跳转后滚动条如何回到顶部","slug":"vue跳转后滚动条如何回到顶部","date":"2017-07-14T09:03:25.000Z","updated":"2018-08-08T03:08:28.535Z","comments":true,"path":"archives/13522.html","link":"","permalink":"https://sweida.github.io/archives/13522.html","excerpt":"","text":"当你页面滑动到页面中间，然后页面跳转时滚动条会保持在页面中间位置如何让跳转后滚动条回到顶部呢？试试在main.js入口文件配合vue-router写这个 123router.afterEach((to,from,next) =&gt; &#123; window.scrollTo(0,0);&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://sweida.github.io/tags/vue/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"一些神奇的JS功效","slug":"一些神奇的JS功效","date":"2017-04-23T09:16:55.000Z","updated":"2018-08-08T03:08:28.535Z","comments":true,"path":"archives/63713.html","link":"","permalink":"https://sweida.github.io/archives/63713.html","excerpt":"","text":"沉睡排序123456var numbers=[1,2,3,4,5,5,99,4,20,11,200];numbers.forEach((num)=&gt;&#123; setTimeout(()=&gt;&#123; console.log(num) &#125;,num)&#125;) 快速去重 (ES6)1var arr = Array.from(new Set([1,2,3,4,4,3,5,6,7,8,8])); 单行写一个评级组件12\"★★★★★☆☆☆☆☆\".slice(5 - rate, 10 - rate);//定义一个变量rate是1到5的值，然后执行上面代码 论如何优雅的取整12345var a = ~~2.33var b= 2.33 | 0var c= 2.33 &gt;&gt; 0 短路表达式1234567891011121314151617// 条件判断var a = b &amp;&amp; 1// 相当于if (b) &#123; a = 1&#125; else &#123; a = b&#125;var a = b || 1// 相当于if (b) &#123; a = b&#125; else &#123; a = 1&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://sweida.github.io/tags/JavaScript/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://sweida.github.io/categories/前端/"}]},{"title":"Hello Hexo","slug":"Hello Hexo","date":"2017-03-15T09:16:00.000Z","updated":"2018-08-08T03:08:28.511Z","comments":true,"path":"archives/16107.html","link":"","permalink":"https://sweida.github.io/archives/16107.html","excerpt":"","text":"Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://sweida.github.io/tags/hexo/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"https://sweida.github.io/categories/工具/"}]}]}